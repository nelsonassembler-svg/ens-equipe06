#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Conversor de Excel para PDF - Mantém formatação original
Autor: Seu Nome
Licença: MIT
"""

import os
import sys
from pathlib import Path
from typing import List, Tuple, Dict, Any
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.lib.units import mm
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, PageBreak, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER


class ExcelToPDFConverter:
    """
    Conversor de Excel para PDF com preservação de formatação.

    Características:
    - Mantém cores originais
    - Ajusta automaticamente para A4 retrato
    - Suporta múltiplas planilhas
    - Preserva negrito, alinhamento e bordas

    Exemplo:
        >>> converter = ExcelToPDFConverter("input.xlsx")
        >>> converter.convert("output.pdf")
    """

    # Configurações editáveis
    PAGE_SIZE = A4
    ORIENTATION = 'portrait'
    MARGIN = 15 * mm
    DEFAULT_FONT_SIZE = 8
    HEADER_FONT_SIZE = 9
    TITLE_FONT_SIZE = 14

    def __init__(self, excel_path: str):
        """
        Inicializa o conversor.

        Args:
            excel_path: Caminho para o arquivo Excel

        Raises:
            FileNotFoundError: Se o arquivo não existir
        """
        self.excel_path = Path(excel_path)
        if not self.excel_path.exists():
            raise FileNotFoundError(f"Arquivo não encontrado: {excel_path}")

        self.workbook = None
        self.page_width = self.PAGE_SIZE[0]
        self.page_height = self.PAGE_SIZE[1]

    def load_workbook(self) -> bool:
        """Carrega o arquivo Excel."""
        try:
            self.workbook = load_workbook(self.excel_path, data_only=False)
            print(f"✓ Arquivo carregado: {self.excel_path.name}")
            return True
        except Exception as e:
            print(f"✗ Erro ao carregar: {e}")
            return False

    def _hex_to_rgb(self, hex_color: str) -> Tuple[float, float, float]:
        """
        Converte cor hexadecimal para RGB normalizado.

        Args:
            hex_color: String hexadecimal (ex: "FF0000" ou "FFFF0000")

        Returns:
            Tupla (r, g, b) com valores entre 0 e 1
        """
        # Remove prefixo alpha se existir (ARGB -> RGB)
        if len(hex_color) == 8:
            hex_color = hex_color[2:]

        try:
            r = int(hex_color[0:2], 16) / 255.0
            g = int(hex_color[2:4], 16) / 255.0
            b = int(hex_color[4:6], 16) / 255.0
            return (r, g, b)
        except (ValueError, IndexError):
            return (0, 0, 0)  # Preto como fallback

    def get_cell_style(self, cell) -> Dict[str, Any]:
        """
        Extrai estilo de uma célula do Excel.

        Args:
            cell: Célula do openpyxl

        Returns:
            Dicionário com propriedades de estilo
        """
        style = {
            'font_color': colors.black,
            'bg_color': colors.white,
            'font_size': self.DEFAULT_FONT_SIZE,
            'bold': False,
            'alignment': 'LEFT'
        }

        try:
            # Cor da fonte
            if cell.font and cell.font.color:
                if hasattr(cell.font.color, 'rgb') and cell.font.color.rgb:
                    rgb = self._hex_to_rgb(cell.font.color.rgb)
                    style['font_color'] = colors.Color(*rgb)

            # Cor de fundo
            if cell.fill and cell.fill.start_color:
                if hasattr(cell.fill.start_color, 'rgb') and cell.fill.start_color.rgb:
                    rgb = self._hex_to_rgb(cell.fill.start_color.rgb)
                    # Ignora branco puro (fundo padrão)
                    if rgb != (1.0, 1.0, 1.0):
                        style['bg_color'] = colors.Color(*rgb)

            # Negrito
            if cell.font and cell.font.bold:
                style['bold'] = True
                style['font_size'] = self.HEADER_FONT_SIZE

            # Alinhamento
            if cell.alignment:
                if cell.alignment.horizontal == 'center':
                    style['alignment'] = 'CENTER'
                elif cell.alignment.horizontal == 'right':
                    style['alignment'] = 'RIGHT'

        except Exception as e:
            print(f"⚠ Aviso: Erro ao extrair estilo: {e}")

        return style

    def process_sheet(self, sheet) -> Tuple[List[List[str]], List[List[Dict]]]:
        """
        Processa uma planilha extraindo dados e estilos.

        Args:
            sheet: Planilha do openpyxl

        Returns:
            Tupla (dados, estilos)
        """
        data = []
        styles_map = []

        for row in sheet.iter_rows():
            row_data = []
            row_styles = []

            for cell in row:
                # Valor
                value = "" if cell.value is None else str(cell.value)
                row_data.append(value)

                # Estilo
                row_styles.append(self.get_cell_style(cell))

            data.append(row_data)
            styles_map.append(row_styles)

        return data, styles_map

    def create_table_style(self, styles_map: List[List[Dict]]) -> TableStyle:
        """
        Cria estilo de tabela baseado nos estilos das células.

        Args:
            styles_map: Mapa de estilos das células

        Returns:
            TableStyle do ReportLab
        """
        commands = [
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 3),
            ('RIGHTPADDING', (0, 0), (-1, -1), 3),
            ('TOPPADDING', (0, 0), (-1, -1), 3),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
        ]

        # Aplica estilos individuais
        for row_idx, row_styles in enumerate(styles_map):
            for col_idx, cell_style in enumerate(row_styles):
                pos = (col_idx, row_idx)

                # Background
                commands.append(('BACKGROUND', pos, pos, cell_style['bg_color']))

                # Cor do texto
                commands.append(('TEXTCOLOR', pos, pos, cell_style['font_color']))

                # Tamanho da fonte
                commands.append(('FONTSIZE', pos, pos, cell_style['font_size']))

                # Negrito
                font_name = 'Helvetica-Bold' if cell_style['bold'] else 'Helvetica'
                commands.append(('FONTNAME', pos, pos, font_name))

                # Alinhamento
                commands.append(('ALIGN', pos, pos, cell_style['alignment']))

        return TableStyle(commands)

    def calculate_column_widths(self, num_cols: int) -> List[float]:
        """
        Calcula larguras das colunas para caber em A4.

        Args:
            num_cols: Número de colunas

        Returns:
            Lista de larguras
        """
        available_width = self.page_width - (2 * self.MARGIN)
        col_width = available_width / num_cols
        return [col_width] * num_cols

    def convert(self, output_path: str = "output.pdf") -> bool:
        """
        Converte Excel para PDF.

        Args:
            output_path: Caminho do PDF de saída

        Returns:
            True se sucesso, False caso contrário
        """
        if not self.load_workbook():
            return False

        try:
            # Cria documento
            doc = SimpleDocTemplate(
                output_path,
                pagesize=self.PAGE_SIZE,
                leftMargin=self.MARGIN,
                rightMargin=self.MARGIN,
                topMargin=self.MARGIN,
                bottomMargin=self.MARGIN
            )

            elements = []
            styles = getSampleStyleSheet()

            # Estilo do título
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=self.TITLE_FONT_SIZE,
                textColor=colors.HexColor('#1F4E78'),
                spaceAfter=12,
                alignment=TA_CENTER,
                fontName='Helvetica-Bold'
            )

            # Processa cada planilha
            for idx, sheet_name in enumerate(self.workbook.sheetnames):
                sheet = self.workbook[sheet_name]

                # Título
                title = Paragraph(sheet_name.upper(), title_style)
                elements.append(title)
                elements.append(Spacer(1, 6))

                # Dados e estilos
                data, styles_map = self.process_sheet(sheet)

                if not data:
                    continue

                # Cria tabela
                num_cols = len(data[0])
                col_widths = self.calculate_column_widths(num_cols)

                table = Table(data, colWidths=col_widths, repeatRows=1)
                table.setStyle(self.create_table_style(styles_map))

                elements.append(table)

                # Quebra de página (exceto última)
                if idx < len(self.workbook.sheetnames) - 1:
                    elements.append(PageBreak())

            # Gera PDF
            doc.build(elements)

            print(f"✓ PDF gerado: {output_path}")
            print(f"✓ Tamanho: A4 {self.ORIENTATION.upper()}")
            return True

        except Exception as e:
            print(f"✗ Erro ao gerar PDF: {e}")
            import traceback
            traceback.print_exc()
            return False


def main():
    """Função principal para uso via linha de comando."""
    if len(sys.argv) < 2:
        print("Uso: python converter.py <arquivo.xlsx> [saida.pdf]")
        print("\nExemplo:")
        print("  python converter.py calendario.xlsx")
        print("  python converter.py calendario.xlsx meu_calendario.pdf")
        sys.exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "output.pdf"

    try:
        converter = ExcelToPDFConverter(input_file)
        success = converter.convert(output_file)
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"✗ Erro: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
